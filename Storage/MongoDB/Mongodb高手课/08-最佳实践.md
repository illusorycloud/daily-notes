# 最佳实践

## 1. 连接到 MongoDB

* 关于驱动程序:总是选择与所用之MongoDB相兼容的驱动程序。这可以很容易地从驱动兼容对照表中查到;
* 如果使用第三方框架(如Spring Data)，则还需要考虑框架版本与驱动的兼容性;
* 关于连接对象MongoClient: 使用MongoClient对象连接到MongoDB实例时总是应该保证它**单例**，并且在整个生命周期中都从它获取其他操作对象。
* 关于连接字符串:连接字符串中可以配置大部分连接选项，建议总是在连接字符串中配置这些选项;



```sh
//连接到复制集 把所有节点都写上
mongodb://节点1,节点2,节点.../database?[options]
//连接到分片集
mongodb://mongos 1,mongos2,mongos3.../ database?[options]
```



### 常见连接字符串参数

* maxPoolSize
  * 连接池大小
* Max Wait Time
  * 建议设置，自动杀掉太慢的查询
* Write Concern
  * 建议majority 保证数据安全
* Read Concern
  * 对于数据一-致性要求高的场景适当使用

### 连接字符串节点和地址

* 无论对于复制集或分片集，连接字符串中都应**尽可能多地提供节点地址**,建议**全部列出**;
  * 复制集利用这些地址可以更有效地发现集群成员;
  * 分片集利用这些地址可以更有效地分散负载;

* 连接字符串中尽可能使用与复制集内部配置相同的域名或IP;

使用域名连接集群

在配置集群时使用域名可以为集群变更时提供一层额外的保护。例如需要将集群整体迁移到新网段，直接修改域名解析即可。
另外，MongoDB提供的mongodb+srv://协议可以提供额外一层的保护。该协议允许通过域名解析得到所有mongos或节点的地址，而不是写在连接字符串中。

```sh
mongodb+srv://server.example.com/
Record TTL Class Priority Weight Port Target_ mongodb._ _tcp.server.example.com. 86400
IN SRV 05 27317 mongodb1 .example.com.
_mongodb._ _tcp.server.example.com. 86400 IN SRV 0 527017 mongodb2.example.com.
```

**不要 mongos 或复制集上层放置负载均衡器，让驱动处理负载均衡和自动故障恢复**。

### Cursor

如果一个游标已经遍历完，则会自动关闭;如果没有遍历完，则需要手动调用close()方法，否则该游标将在服务器上存在10分钟(默认值)后超时释放，造成不必要的资源浪费。
但是，如果不能遍历完一个游标，通常意味着查询条件太宽泛，更应该考虑的问题是如何将条件收紧。

## 2. 常见场景

### 1. 查询及索引

* 每个查询都必须要有对应的索引
* 尽量使用覆盖索引Covered Indexes ( 可以避免读数据文件)
* 使用projection来减少返回到客户端的的文档的内容



### 2. 关于写入操作

* 在update语句里只包括需要更新的字段
* 尽可能使用批量插入来提升写入性能
* 使用TTL自动过期日志类型的数据



### 3. 文档结构

* 防止使用太长的字段名( 浪费空间)
* 防止使用太深的数组嵌套(超过2层操作比较复杂)
* 不使用中文，标点符号等非拉丁字母作为字段名




### 4. 分页问题

#### 避免使用count

尽可能不要计算总页数，特别是数据量大和查询条件不能完整命中索引时。
考虑以下场景：

假设集合总共有1000w条数据，在没有索引的情况下考虑以下查询:

```sh
db.coll.find({x: 100}).limit(50);
db.coll.count({x: 100});
```

* 前者只需要遍历前n条，直到找到50条队伍x=100的文档即可结束;
* 后者需要遍历完1000w条找到所有符合要求的文档才能得到结果。

为了计算总页数而进行的count()往往是拖慢页面整体加载速度的原因。

#### 巧分页

避免使用skip/limit形式的分页,特别是数据量大的时候;
替代方案:使用查询条件+唯一排序条件; 
例如:

```sh
第一页: db.posts.find({}).sort({ id: 1}).limit(20);
第二页: db.posts.find({ id: {$gt: <第一页最后-个_ id>}).sort({ id: 1}).limit(20);
第三页: db.posts.find({ _id: {$gt: <第=页最后一个id}).sort({ _id: 1}).limit(20);
```



### 5. 关于事务

使用事务的原则:

* 无论何时，事务的使用总是能避免则避免;
* 模型设计先于事务，尽可能用模型设计规避事务;
* 不要使用过大的事务(尽量控制在1000个文档更新以内) ;
* 当必须使用事务时，尽可能让涉及事务的文档分布在同一个分片上,这
  将有效地提高效率;

