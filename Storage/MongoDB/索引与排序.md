# 索引与排序

## 1. 概述

线上有一条SQL执行很慢，具体SQL如下

```sh
db.getCollection("collection").find({"KeyA":xxx}).sort({"_id":-1}).limit(20);
```

其中 KeyA 是有建立索引的，按理说应该会执行得特别快，实际却要执行超过30秒。

MongoDB Collection中大概2000W数据。



原因分析：

使用Explain查看确实也是走了索引的，而且还有limit(20)限制只返回20条数据，那为什么会这么慢呢？

因为还用到了一个排序`sort({"_id":-1})`。

因为要排序，索引MongoDB只能把所有数据都取出来，排序后根据limit取20条返回，相当于这种情况下limit完全没有效果。

优化前的Explain，可以看到要扫描100W行索引和100W行文档。

```sh
        "nReturned" : 20.0, 
        "totalKeysExamined" : 1322497.0, 
        "totalDocsExamined" : 1322497.0, 
```



后续将单列索引KeyA修改为了KeyA+_id联合索引，再次测试就非常快了。因为联合索引中有排序字段`_id`所以从索引树中取出来的数据就已经是有序的，省去了排序过程，自然特别快。

响应时间从30秒变成了2ms。

优化后的Explain，只需要扫描20行文档了，因为索引中就包含了排序字段，不用去查询出具体文档即可完成排序（有点类似于覆盖索引的概念）。

```sh
        "nReturned" : 20.0, 
        "totalKeysExamined" : 77290.0, 
        "totalDocsExamined" : 20.0, 
```



## 2. 小结

通过联合索引可以省去部分排序的开销，相应的写入的时候就需要多维护一个索引字段。



也有一定分治的味道或者渐进式的感觉，将查询时的排序消耗分摊到多次写入过程中去。

这其中的具体取舍（trade-off）即需要根据业务场景来自行判断。

